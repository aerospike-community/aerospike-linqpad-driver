﻿<#@ template debug="false" hostSpecific="false" #>
<#@ output extension=".cs" #>
<#@ import namespace="System" #>
<#@ import namespace="System.Collections.Generic" #>
<#
    string[] nativeDataTypes = new string[] 
      { "string", "bool", "Enum", "Guid",
        "short", "int", "long",
        "ushort", "uint", "ulong",
        "decimal", "float", "double", "byte", "sbyte",
        "DateTime", "DateTimeOffset", "TimeSpan" };
	
    Type[] nativeclassDataTypesOf = new Type[] 
      { typeof(string), typeof(bool), typeof(Enum), typeof(Guid),
        typeof(short), typeof(int), typeof(long),
        typeof(ushort), typeof(uint), typeof(ulong),
        typeof(decimal), typeof(float), typeof(double), typeof(byte), typeof(sbyte),
        typeof(DateTime), typeof(DateTimeOffset), typeof(TimeSpan) };

    string[] jsonClassDataTypes = new string[] 
      { "JObject", "JArray", "JValue", "JToken"};
#>

using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Diagnostics;
using Newtonsoft.Json.Linq;
using Newtonsoft.Json;

namespace Aerospike.Database.LINQPadDriver.Extensions
{
    /// <summary>
    /// A wrapper around an <see cref="Object"/> value. 
    /// This is used as an aid so that casting is not required to perform comparison operations, etc.
    /// This object also performs implicit casting to standard .Net data types while using LINQ...  
    /// </summary>
    /// <seealso cref="APrimaryKey"/>
    /// <seealso cref="AValue.ToValue(object)"/>
    /// <seealso cref="AValue.ToValue(Client.Bin)"/>
    /// <seealso cref="AValue.ToValue(Client.Value)"/>
    /// <seealso cref="APrimaryKey.ToValue(Client.Key)"/>
    /// <seealso cref="Aerospike.Client.LPDHelpers.ToAValue(Client.Bin)"/>
    /// <seealso cref="Aerospike.Client.LPDHelpers.ToAPrimaryKey(Client.Key)"/>
    /// <seealso cref="Aerospike.Client.LPDHelpers.ToAValue(Client.Value)"/>
    /// <seealso cref="Aerospike.Client.LPDHelpers.ToAValue(object)"/>
    /// <seealso cref="AValueHelper.Cast{TResult}(IEnumerable{AValue})"/>
    /// <seealso cref="AValueHelper.OfType{TResult}(IEnumerable{AValue})"/>
    [DebuggerDisplay("{DebuggerString()}")]
    public class AValue : IConvertible,
                            IComparable,
                            IEquatable<AValue>,
                            IEqualityComparer<AValue>,
                            IComparable<AValue>,
                            IEquatable<Aerospike.Client.Key>,
                            IEqualityComparer<Aerospike.Client.Key>,
                            IComparable<Aerospike.Client.Key>,
                            IEquatable<Aerospike.Client.Value>,
                            IEqualityComparer<Aerospike.Client.Value>,
                            IComparable<Aerospike.Client.Value>
        <# foreach(var datatype in nativeDataTypes)
        { #>
            , IEquatable< <#= datatype #> >
            , IEqualityComparer< <#= datatype #> >
            , IComparable< <#= datatype #> >            
         <#    }//end of foreach data type #>  
         <# foreach(var datatype in jsonClassDataTypes)
        { #>
            , IEquatable< <#= datatype #> >
            , IEqualityComparer< <#= datatype #> >
         <#    }//end of foreach data type #>  
    {

        public AValue(Aerospike.Client.Bin bin) 
            : this(bin.value, bin.name)
        { }

        public AValue(Aerospike.Client.Value value, string binName = null) 
            : this(value.Object, binName ?? "Value", "Value")
        { }

        public AValue(object value, string binName, string fldName)
        {
            this.Value = value is AValue aValue ? aValue.Value : value;
            this.BinName = binName;
            this.FldName = fldName;
        }

        public AValue(AValue aValue)
            : this(aValue.Value, aValue.BinName, aValue.FldName)
        {            
        }

        /// <summary>
        /// Returns the actual value from the <see cref="Aerospike.Client.Record"/>
        /// </summary>
        public Object Value { get; }
        /// <summary>
        /// Returns the Aerospike Bin Name
        /// </summary>
        public string BinName { get; }
        /// <summary>
        /// Returns the name of the associated field/property
        /// </summary>
        public string FldName { get; }

        /// <summary>
        /// The <see cref="Value"/> type
        /// </summary>
        public Type UnderlyingType { get => this.Value.GetType(); }


        /// <summary>
        /// Returns true if the value is a string
        /// </summary>
        /// <seealso cref="IsCDT"/>
        /// <seealso cref="IsMap"/>
        /// <seealso cref="IsList"/>
        /// <seealso cref="IsBool"/>
        /// <seealso cref="IsFloat"/>
        /// <seealso cref="IsInt"/>
        /// <seealso cref="IsJson"/>
        /// <seealso cref="UnderlyingType"/>
        public bool IsString
        {
            get => this.UnderlyingType == typeof(string);
        }

        /// <summary>
        /// Returns true if the value is any numeric type (e.g., long, double, etc.)
        /// </summary>
        /// <seealso cref="IsCDT"/>
        /// <seealso cref="IsMap"/>
        /// <seealso cref="IsList"/>
        /// <seealso cref="IsBool"/>
        /// <seealso cref="IsFloat"/>
        /// <seealso cref="IsInt"/>
        /// <seealso cref="IsJson"/>
        /// <seealso cref="IsString"/>
        /// <seealso cref="UnderlyingType"/>
        public bool IsNumeric
        {
            get => Helpers.IsNumeric(this.UnderlyingType);
        }

        /// <summary>
        /// Returns true if the value is any whole number type (e.g., int, uint, long, ulong, etc.)
        /// </summary>
        /// <seealso cref="IsCDT"/>
        /// <seealso cref="IsMap"/>
        /// <seealso cref="IsList"/>
        /// <seealso cref="IsBool"/>
        /// <seealso cref="IsFloat"/>
        /// <seealso cref="IsJson"/>
        /// <seealso cref="IsNumeric"/>
        /// <seealso cref="IsString"/>
        /// <seealso cref="UnderlyingType"/>
        public bool IsInt
        {
            get => Helpers.IsInt(this.UnderlyingType);
        }

        /// <summary>
        /// Returns true if the value is any float type (e.g., float, double)
        /// </summary>
        /// <seealso cref="IsCDT"/>
        /// <seealso cref="IsMap"/>
        /// <seealso cref="IsList"/>
        /// <seealso cref="IsBool"/>
        /// <seealso cref="IsJson"/>
        /// <seealso cref="IsInt"/>
        /// <seealso cref="IsNumeric"/>
        /// <seealso cref="IsString"/>
        /// <seealso cref="UnderlyingType"/>
        public bool IsFloat
        {
            get => Helpers.IsFloat(this.UnderlyingType);
        }

        /// <summary>
        /// Returns true if the value is boolean
        /// </summary>
        /// <seealso cref="IsCDT"/>
        /// <seealso cref="IsMap"/>
        /// <seealso cref="IsList"/>
        /// <seealso cref="IsJson"/>
        /// <seealso cref="IsFloat"/>
        /// <seealso cref="IsInt"/>
        /// <seealso cref="IsNumeric"/>
        /// <seealso cref="IsString"/>
        /// <seealso cref="UnderlyingType"/>
        public bool IsBool
        {
            get => this.UnderlyingType == typeof(bool);
        }

        /// <summary>
        /// Returns true if the value is a IList
        /// </summary>
        /// <seealso cref="IsCDT"/>
        /// <seealso cref="IsMap"/>
        /// <seealso cref="IsJson"/>
        /// <seealso cref="IsBool"/>
        /// <seealso cref="IsFloat"/>
        /// <seealso cref="IsInt"/>
        /// <seealso cref="IsNumeric"/>
        /// <seealso cref="IsString"/>
        /// <seealso cref="UnderlyingType"/>
        public bool IsList
        {
            get => Helpers.IsSubclassOfInterface(typeof(IList<>), this.UnderlyingType);
        }

        /// <summary>
        /// Returns true if the value is a IDictionary
        /// </summary>
        /// <seealso cref="IsCDT"/>
        /// <seealso cref="IsJson"/>
        /// <seealso cref="IsList"/>
        /// <seealso cref="IsBool"/>
        /// <seealso cref="IsFloat"/>
        /// <seealso cref="IsInt"/>
        /// <seealso cref="IsNumeric"/>
        /// <seealso cref="IsString"/>
        /// <seealso cref="UnderlyingType"/>
        public bool IsMap
        {
            get => Helpers.IsSubclassOfInterface(typeof(IDictionary<,>), this.UnderlyingType);
        }

        /// <summary>
        /// Returns true if the value is a Collection Data Type (e.g., IList, IDictionary)
        /// </summary>
        /// <seealso cref="IsJson"/>
        /// <seealso cref="IsMap"/>
        /// <seealso cref="IsList"/>
        /// <seealso cref="IsBool"/>
        /// <seealso cref="IsFloat"/>
        /// <seealso cref="IsInt"/>
        /// <seealso cref="IsNumeric"/>
        /// <seealso cref="IsString"/>
        /// <seealso cref="UnderlyingType"/>
        public bool IsCDT
        {
            get => this.IsList || this.IsMap;
        }

        /// <summary>
        /// Returns true if the value is a JSON Data Type (e.g., JObject, JArray, etc.)
        /// </summary>
        /// <seealso cref="IsCDT"/>
        /// <seealso cref="IsMap"/>
        /// <seealso cref="IsList"/>
        /// <seealso cref="IsBool"/>
        /// <seealso cref="IsFloat"/>
        /// <seealso cref="IsInt"/>
        /// <seealso cref="IsNumeric"/>
        /// <seealso cref="IsString"/>
        /// <seealso cref="UnderlyingType"/>
        public bool IsJson
        {
            get => Helpers.IsJson(this.UnderlyingType);
        }

        public bool IsGeoJson
        {
            get => this.Value is Client.Value.GeoJSONValue || GeoJSONHelpers.IsGeoValue(this.UnderlyingType);
        }

        public bool IsDateTime
        {
            get => this.UnderlyingType == typeof(DateTime);
        }

        public bool IsDateTimeOffset
        {
            get => this.UnderlyingType == typeof(DateTimeOffset);
        }

        public bool IsTimeSpan
        {
            get => this.UnderlyingType == typeof(TimeSpan);
        }

        /// <summary>
        /// Tries to convert <see cref="Value"/> to a JToken.
        /// </summary>
        /// <returns>A <see cref="JToken"/> or an empty JToken</returns>
        public JToken ToJson()
        {
            if (
            <# foreach(var datatype in jsonClassDataTypes)
            { #>
                this.UnderlyingType == typeof(<#= datatype #>) ||
            <#    }//end of foreach data type #>
                false)
            {
                return (JToken)this.Value;
            }

            try
            {
                return (JToken)Newtonsoft.Json.JsonConvert.SerializeObject(this.Value);
            } catch
            {
                return new JObject();
            }
        }

        /// <summary>
        /// Tries to convert <see cref="Value"/> to a IDictionary. If not possible an empty IDictionary is returned.
        /// </summary>
        /// <returns>
        /// An IDictionary, if possible, or an empty IDictionary.
        /// </returns>
        public IDictionary<object, object> ToDictionary()
        {
            if (this.Value is JObject jObject)
            {                
                return CDTConverter.ConvertToDictionary(jObject)
                        .ToDictionary(kvp => (object)kvp.Key, kvp => kvp.Value);               
            }
            else if (this.Value is JProperty jProp)
            {
                return CDTConverter.ConvertToDictionary(jProp)
                        .ToDictionary(kvp => (object)kvp.Key, kvp => kvp.Value);
            }
            else if (this.Value is IDictionary<object, object> oDict)
                return oDict;
            else if (this.Value is IDictionary<string, object> sDict)
                return sDict.ToDictionary(kvp => (object)kvp.Key, kvp => kvp.Value);
            else if (this.Value is System.Collections.IDictionary iDict)
            {                
                var kvps = iDict.Keys.Cast<object>().Zip(iDict.Values.Cast<object>(),
                                                            (k,v) => new KeyValuePair<object,object>(k, v));
                return new Dictionary<object, object>(kvps);
            }

            return new Dictionary<object, object>(0);
        }

        /// <summary>
        /// Tries to convert <see cref="Value"/> to a IList. If not possible an empty list is returned.
        /// </summary>
        /// <returns>
        /// An IList, if possible, otherwise an empty IList.
        /// </returns>
        public IList<object> ToList()
        {    
            if(this.Value is IList<object> iList)
            {
                return iList;
            }  
            else if (this.Value is JObject
                        || this.Value is JProperty)
            {
                return this.ToDictionary()
                            .Cast<object>().ToList();
            }
            else if(this.Value is JArray jArray)
            {
                return CDTConverter.ConvertToList(jArray);                
            }                                
            else if(this.Value is System.Collections.IEnumerable iEnum)
            {
                return iEnum.Cast<object>().ToList();
            }

            return new List<object>(0);
        }

        /// <summary>
        /// Always convert <see cref="Value"/> to a List. 
        /// If <see cref="Value"/> is not a collection, the item is returned in a list.
        /// </summary>
        /// <returns>
        /// A list of at least one element. If <see cref="Value"/> is a collection, that collection will be converted to an IList.
        /// </returns>
        public IList<object> ToListItem()
        { 
            if(this.IsCDT
                || this.Value is JProperty)
            {
                return this.ToList();
            }
            if(this.Value is JValue jValue)
                return new List<object>(1) { jValue.Value };

            return new List<object>(1) { this.Value };
        }

        /// <summary>
        /// This will convert a list of <see cref="JsonDocument"/>/<see cref="JObject"/> to a list of dictionary items if they match that patterns.
        /// If the value is already a list of dictionary items, that is returned.
        /// </summary>
        /// <returns>
        /// a list of dictionary items or an empty list.
        /// </returns>
        public IEnumerable<IDictionary<string,object>> ToCDT()
        {            
            var listItem = this.ToList();

            if(listItem.Count > 0)
            {
                if (Helpers.IsJsonDoc(listItem.GetType().GenericTypeArguments[0]))
                {
                    return Aerospike.Client.LPDHelpers.ToCDT(listItem.Cast<JObject>());                    
                }
               
                static JsonDocument IsDoc(object value)
                {
                    if (value is IDictionary<object, object> dict)
                    {
                        return new JsonDocument(dict);
                    }
                    if (value is JsonDocument jdoc)
                    {
                        return jdoc;
                    }
                    if (value is JObject jObj)
                    {
                        return new JsonDocument(jObj);
                    }

                    return null;
                }

                return Aerospike.Client.LPDHelpers.ToCDT(listItem
                                                            .Select(i => IsDoc(i))
                                                            .Where(i => i != null));
            }
       
            return new List<IDictionary<string,object>>(0);;
        }

        /// <summary>
        /// Converts <see cref="Value"/> into a .net native type, a <see cref="Newtonsoft.Json"/>, or <see cref="GeoJSON.Net.GeoJSONObject"/> instance.
        /// </summary>
        /// <typeparam name="T">Try to convert <see cref="Value"/> to this type</typeparam>
        /// <returns>
        /// The converted value
        /// </returns>
        /// <exception cref="ArgumentException">Thrown if value cannot be converted</exception>
        public T Convert<T>() => this.Value is T tValue? tValue : (T) Helpers.CastToNativeType(this.FldName, typeof(T), this.BinName, this.Value);

        /// <summary>
        /// Returns an enumerable object, if possible.
        /// </summary>
        /// <typeparam name="T">The element type</typeparam>
        /// <returns>
        /// Returns an enumerable object
        /// </returns>
        public IEnumerable<T> AsEnumerable<T>() => (T[]) this.Convert<T[]>();
        /// <summary>
        /// Returns an enumerable object, if possible.
        /// </summary>
        /// <returns>
        /// Returns an enumerable object
        /// </returns>
        public System.Collections.IEnumerable AsEnumerable() => (object[]) this.Convert<object[]>();

        virtual public object ToDump()
        {
            return this.Value;
        }

        protected virtual bool DigestRequired() => false;
        protected virtual bool CompareDigest(object value) => false;

        public bool Equals(Aerospike.Client.Key key)
        {
            if(this.DigestRequired())
                return this.CompareDigest(key);
                                                
           if(this.Value is null || key is null)
           {
                if(key is null) return false;                
           }
           return this.Equals(key.userKey);
        }
        public bool Equals(Aerospike.Client.Key key1, Aerospike.Client.Key key2)
        {
            if(key1 is null) return key2 is null;
            if(key1.userKey is null) 
            {
                if(key2 is null) return false;
                return key2.userKey is null ;
            }

            return key1.Equals(key2);
        }
        public int GetHashCode(Aerospike.Client.Key key) => key?.GetHashCode() ?? 0;

        public bool Equals(Aerospike.Client.Value value)
        {
            if(this.DigestRequired())
                return this.CompareDigest(value?.Object);
                                                
           if(this.Value is null || value is null)
           {
                if(value is null) return false;
                return value.Type == Aerospike.Client.Value.NullValue.Instance.Type;
           }
           return Helpers.Equals(this.Value, value.Object);
        }
        public bool Equals(Aerospike.Client.Value v1, Aerospike.Client.Value v2)
        {
            if(v1 is null) return v2 is null;
            if(v1.Object is null)
            {
                if(v2 is null) return false;
                return v2.Object is null;
            }

            return v1.Object.Equals(v2.Object);
        }
        public int GetHashCode(Aerospike.Client.Value value) => value?.Object?.GetHashCode() ?? 0;
        
        public bool Equals(AValue value)
        {
            if(this.DigestRequired())
                return this.CompareDigest(value);
                                                
           if(this.Value is null || value is null)
           {
                if(value is null) return false;
                return value.Value is null;
           }

           if(value.DigestRequired()) return value.CompareDigest(this);

           return Helpers.Equals(this.Value, value.Value);
        }
        public bool Equals(AValue v1, AValue v2)
        {
            if(v1 is null) return v2 is null;
            
            return v1.Equals(v2);
        }
        public int GetHashCode(AValue value) => value?.GetHashCode() ?? 0;

        public override string ToString() => this.Value?.ToString();
        public string DebuggerString() => $"{this.FldName ?? this.BinName}{{{this.Value} ({this.UnderlyingType?.Name})}}";

#pragma warning disable CS0618 // Type or member is obsolete
        /// <summary>
        /// Returns the string for <see cref="Value"/> using the given format, if possible.         
        /// Otherwise the ToString of <see cref="Value"/> is used.
        /// </summary>
        /// <param name="format">A composite format string.</param>
        /// <param name="throwOnFormatException">
        /// If true and a format exception occurs, it will be re-thrown.
        /// The default is false and the ToString value is returned.
        /// </param>
        /// <returns>The string value of <see cref="Value"/></returns>
        public string ToString(string format, bool throwOnFormatException = false)
        {
            try
            {
                switch(this.Value)
                {
                    <# foreach(var datatype in nativeclassDataTypesOf)
                    {
                       if(datatype.GetMethod("ToString", new Type[] { typeof(string) }) != null)
                        { #>
    case <#= datatype #> v<#= datatype.Name #>:
                        return v<#= datatype.Name #>.ToString(format);
                        <# }//end of if
                    }//end of foreach data type #>
                    default:
                        break;
                }
                throwOnFormatException = false;
                return String.Format($"{{0:{format}}}", this.Value);
            }
            catch(FormatException)
            {
                if(throwOnFormatException) throw;
            }

            return this.ToString();
        }

        /// <summary>
        /// Returns the string for <see cref="Value"/> using the given provider, if possible.         
        /// Otherwise the ToString of <see cref="Value"/> is used.
        /// </summary>
        /// <param name="provider">An object that supplies culture-specific formatting information.</param>
        /// <param name="throwOnFormatException">
        /// If true and a format exception occurs, it will be re-thrown.
        /// The default is false and the ToString value is returned.
        /// </param>
        /// <returns>The string value of <see cref="Value"/></returns>
        public string ToString(IFormatProvider provider, bool throwOnFormatException = false)
        {
            try
            {
                switch(this.Value)
                {
                    <# foreach(var datatype in nativeclassDataTypesOf)
                    {
                       if(datatype.GetMethod("ToString", new Type[] { typeof(IFormatProvider) }) != null)
                        { #>
    case <#= datatype #> v<#= datatype.Name #>:
                        return v<#= datatype.Name #>.ToString(provider);
                        <# }//end of if
                    }//end of foreach data type #>
                    default:
                        break;
                }

                return String.Format(provider, "{0}", this.Value);
            }
            catch(FormatException)
            {
                if(throwOnFormatException) throw;
            }
            return this.ToString();
        }

        /// <summary>
        /// Returns the string for <see cref="Value"/> using the given format and provider, if possible.         
        /// Otherwise the ToString of <see cref="Value"/> is used.
        /// </summary>
        /// <param name="format">A composite format string.</param>
        /// <param name="provider">An object that supplies culture-specific formatting information.</param> 
        /// <param name="throwOnFormatException">
        /// If true and a format exception occurs, it will be re-thrown.
        /// The default is false and the ToString value is returned.
        /// </param>
        /// <returns>The string value of <see cref="Value"/></returns>
        public string ToString(string format, IFormatProvider provider, bool throwOnFormatException = false)
        {
            try
            {
                switch(this.Value)
                {
                    <# foreach(var datatype in nativeclassDataTypesOf)
                    {
                       if(datatype.GetMethod("ToString", new Type[] { typeof(string), typeof(IFormatProvider) }) != null)
                        { #>
    case <#= datatype #> v<#= datatype.Name #>:
                        return v<#= datatype.Name #>.ToString(format, provider);
                        <# }//end of if
                    }//end of foreach data type #>
                    default:
                        break;
                }
                throwOnFormatException = false;
                return String.Format(provider, $"{{0:{format}}}", this.Value);
            }
            catch(FormatException)
            {
                if(throwOnFormatException) throw;
            }
            return this.ToString();
        }
#pragma warning restore CS0618 // Type or member is obsolete

        /// <summary>
        /// Returns the JSON string for <see cref="Value"/> using the given formatting and converters only if <see cref="Value"/> is a JToken.
        /// Otherwise the ToString of <see cref="Value"/>.
        /// </summary>
        /// <param name="formatting">Indicates how the output should be formatted.</param>
        /// <param name="converters">A collection of <see cref="JsonConverter"/>s which will be used when writing the token.</param>
        /// <returns>The JSON string or the ToString of <see cref="Value"/></returns>
        public string ToString(Formatting formatting, params JsonConverter[] converters)
        {
            if(this.Value is JToken jToken)
                return jToken.ToString(formatting, converters);
            return this.ToString();
        }

        public override int GetHashCode() => this.Value?.GetHashCode() ?? 0;

        public override bool Equals(object obj)
        {
            if(ReferenceEquals(this,obj)) return true;
            if(obj is Aerospike.Client.Key key) return this.Equals(key);
            if(obj is Aerospike.Client.Value value) return this.Equals(value);
            if(obj is AValue pValue) return this.Equals(pValue);
            
            var invokeEquals = this.GetType().GetMethod("Equals", new Type[] { obj.GetType() });

            if(invokeEquals is null) return Helpers.Equals(this.Value, obj);

            return (bool) invokeEquals.Invoke(this, new object[] { obj });            
        }

        public int CompareTo(object other)
        {
            if(ReferenceEquals(this,other)) return 0;
            if(other is null) return this.Value is null ? 0 : 1;
            if(this.Value is null) return -1;
            if(other is Aerospike.Client.Key key) return this.CompareTo(key);
            if(other is Aerospike.Client.Value value) return this.CompareTo(value);
            if(other is AValue pValue) return this.CompareTo(pValue);
            
            var invokeCompare = this.GetType().GetMethod("CompareTo", new Type[] { other.GetType() });

            if(invokeCompare is null) return Helpers.GetStableHashCode(this.Value).CompareTo(Helpers.GetStableHashCode(other));

            return (int) invokeCompare.Invoke(this, new object[] { other });
        }

        public int CompareTo(AValue other)
        {
            if(other is null) return 1;
            return this.CompareTo(other.Value);
        }

        public int CompareTo(Aerospike.Client.Key other)
        {
            if(other is null) return this.Value is null ? 0 : 1;
            if(this.Equals(other)) return 0;
            if(this.Value is null) return 1;
            if(other.userKey is null) return Helpers.GetStableHashCode(this.Value).CompareTo(Helpers.GetStableHashCode(other.digest));
            
            return this.CompareTo(other.userKey);
        }

        public int CompareTo(Aerospike.Client.Value other)
        {
             if(other is null) return 1;
             return this.CompareTo(other.Object);
        }

         public TypeCode GetTypeCode()
        {
            return Type.GetTypeCode(this.UnderlyingType);
        }

        bool IConvertible.ToBoolean(IFormatProvider provider)
        {
            if(this.Value is IConvertible iConvertible)
                return iConvertible.ToBoolean(provider);

            return (bool) this;
        }

        byte IConvertible.ToByte(IFormatProvider provider)
        {
            if(this.Value is IConvertible iConvertible)
                return iConvertible.ToByte(provider);

            return (byte) this;
        }

        char IConvertible.ToChar(IFormatProvider provider)
        {
            if(this.Value is IConvertible iConvertible)
                return iConvertible.ToChar(provider);

            return (char) this;
        }

        DateTime IConvertible.ToDateTime(IFormatProvider provider)
        {
            if(this.Value is IConvertible iConvertible)
                return iConvertible.ToDateTime(provider);

            return (DateTime) this;
        }

        decimal IConvertible.ToDecimal(IFormatProvider provider)
        {
            if(this.Value is IConvertible iConvertible)
                return iConvertible.ToDecimal(provider);

            return (decimal) this;
        }

        double IConvertible.ToDouble(IFormatProvider provider)
        {
            if(this.Value is IConvertible iConvertible)
                return iConvertible.ToDouble(provider);

            return (double) this;
        }

        short IConvertible.ToInt16(IFormatProvider provider)
        {
            if(this.Value is IConvertible iConvertible)
                return iConvertible.ToInt16(provider);

            return (short) this;
        }

        int IConvertible.ToInt32(IFormatProvider provider)
        {
            if(this.Value is IConvertible iConvertible)
                return iConvertible.ToInt32(provider);

            return (int) this;
        }

        long IConvertible.ToInt64(IFormatProvider provider)
        {
            if(this.Value is IConvertible iConvertible)
                return iConvertible.ToInt64(provider);

            return (long) this;
        }

        sbyte IConvertible.ToSByte(IFormatProvider provider)
        {
            if(this.Value is IConvertible iConvertible)
                return iConvertible.ToSByte(provider);

            return (sbyte) this;
        }

        float IConvertible.ToSingle(IFormatProvider provider)
        {
            if(this.Value is IConvertible iConvertible)
                return iConvertible.ToSingle(provider);

            return (float) this;
        }

        string IConvertible.ToString(IFormatProvider provider)
        {
            if(this.Value is IConvertible iConvertible)
                return iConvertible.ToString(provider);

            return (string) this;
        }

        object IConvertible.ToType(Type conversionType, IFormatProvider provider)
        {
            if(this.Value is IConvertible iConvertible)
                return iConvertible.ToType(conversionType, provider);

            return Helpers.CastToNativeType(this.FldName, conversionType, this.BinName, this.Value);
        }

        ushort IConvertible.ToUInt16(IFormatProvider provider)
        {
            if(this.Value is IConvertible iConvertible)
                return iConvertible.ToUInt16(provider);

            return (ushort) this;
        }

        uint IConvertible.ToUInt32(IFormatProvider provider)
        {
            if(this.Value is IConvertible iConvertible)
                return iConvertible.ToUInt32(provider);

            return (uint) this;
        }

        ulong IConvertible.ToUInt64(IFormatProvider provider)
        {
            if(this.Value is IConvertible iConvertible)
                return iConvertible.ToUInt64(provider);

            return (ulong) this;
        }

        public static AValue ToValue(Aerospike.Client.Value value) => new AValue(value, "Value");
        public static AValue ToValue(Aerospike.Client.Bin bin) => new AValue(bin);
        public static AValue ToValue(object value) => new AValue(value, "Value", "ToValue");
            
        public static bool operator==(AValue value1, AValue value2)
        {
            if(value1 is null) return value2 is null;

            return value1.Equals(value2);
        }
	    public static bool operator!=(AValue value1, AValue value2) => !(value1 == value2);

        public static bool operator<(AValue value1, AValue value2) => value1 is null ? value2 is not null : value1.CompareTo(value2) < 0;
	    public static bool operator>(AValue value1, AValue value2) => value1 is not null && value1.CompareTo(value2) > 0;
        public static bool operator<=(AValue value1, AValue value2) => value1 is null || value1.CompareTo(value2) <= 0;
        public static bool operator>=(AValue value1, AValue value2) => value1 is null ? value2 is null : value1.CompareTo(value2) >= 0;
       
        public static bool operator==(AValue aValue, Aerospike.Client.Value oValue) => aValue?.Equals(oValue) ?? oValue is null;
	    public static bool operator!=(AValue aValue, Aerospike.Client.Value oValue) => !(aValue?.Equals(oValue) ?? oValue is null);               
        public static bool operator==(Aerospike.Client.Value oValue, AValue aValue) => aValue?.Equals(oValue) ?? oValue is null;
	    public static bool operator!=(Aerospike.Client.Value oValue, AValue aValue) => !(aValue?.Equals(oValue) ?? oValue is null);
       
        public static bool operator<(Aerospike.Client.Value oValue, AValue aValue) => aValue is not null && aValue.CompareTo(oValue) > 0;
	    public static bool operator>(Aerospike.Client.Value oValue, AValue aValue) => aValue is null ? oValue is not null : aValue.CompareTo(oValue) < 0;
        public static bool operator<=(Aerospike.Client.Value oValue, AValue aValue) => aValue is null ? oValue is null : aValue.CompareTo(oValue) >= 0;
        public static bool operator>=(Aerospike.Client.Value oValue, AValue aValue) => aValue is null || aValue.CompareTo(oValue) <= 0;

        public static bool operator<(AValue aValue, Aerospike.Client.Value oValue) => aValue is null ? oValue is not null : aValue.CompareTo(oValue) < 0;
	    public static bool operator>(AValue aValue, Aerospike.Client.Value oValue) => aValue is not null && aValue.CompareTo(oValue) > 0;
        public static bool operator<=(AValue aValue, Aerospike.Client.Value oValue) => aValue is null || aValue.CompareTo(oValue) <= 0;
        public static bool operator>=(AValue aValue, Aerospike.Client.Value oValue) => aValue is null ? oValue is null : aValue.CompareTo(oValue) >= 0;

        public static bool operator==(AValue aValue, Aerospike.Client.Key oValue) => aValue?.Equals(oValue) ?? oValue is null;
	    public static bool operator!=(AValue aValue, Aerospike.Client.Key oValue) => !(aValue?.Equals(oValue) ?? oValue is null);               
        public static bool operator==(Aerospike.Client.Key oValue, AValue aValue) => aValue?.Equals(oValue) ?? oValue is null;
	    public static bool operator!=(Aerospike.Client.Key oValue, AValue aValue) => !(aValue?.Equals(oValue) ?? oValue is null);

        public static bool operator<(Aerospike.Client.Key oValue, AValue aValue) => aValue is not null && aValue.CompareTo(oValue) > 0;
	    public static bool operator>(Aerospike.Client.Key oValue, AValue aValue) => aValue is null ? oValue is not null : aValue.CompareTo(oValue) < 0;
        public static bool operator<=(Aerospike.Client.Key oValue, AValue aValue) => aValue is null ? oValue is null : aValue.CompareTo(oValue) >= 0;
        public static bool operator>=(Aerospike.Client.Key oValue, AValue aValue) => aValue is null || aValue?.CompareTo(oValue) <= 0;

        public static bool operator<(AValue aValue, Aerospike.Client.Key oValue) => aValue is null ? oValue is not null : aValue?.CompareTo(oValue) < 0;
	    public static bool operator>(AValue aValue, Aerospike.Client.Key oValue) => aValue is not null && aValue?.CompareTo(oValue) > 0;
        public static bool operator<=(AValue aValue, Aerospike.Client.Key oValue) => aValue is null || aValue?.CompareTo(oValue) <= 0;
        public static bool operator>=(AValue aValue, Aerospike.Client.Key oValue) => aValue is null ? oValue is null : aValue?.CompareTo(oValue) >= 0;

        <# foreach(var datatype in nativeDataTypes)
        { #>

            public static implicit operator <#= datatype #> (AValue v) => v.Convert< <#= datatype #> >();
            //public static implicit operator <#= datatype #>[] (AValue v) => v.Convert<<#= datatype #>[] >();            
            
            public static bool operator==(AValue av, <#= datatype #> v) => av?.Equals(v) ?? false;
	        public static bool operator!=(AValue av, <#= datatype #> v) => !(av == v);
            public static bool operator==(<#= datatype #> v, AValue av) => av == v;
	        public static bool operator!=(<#= datatype #> v, AValue av) => av != v;
           
            public static bool operator==(AValue av, List< <#= datatype #> > v)
                    => Helpers.SequenceEquals(v, av?.Value);
	        public static bool operator!=(AValue av, List< <#= datatype #> > v) => !(av == v);
            public static bool operator==(List< <#= datatype #> > v, AValue av) => av == v;
	        public static bool operator!=(List< <#= datatype #> > v, AValue av) => av != v;

            public static bool operator<(<#= datatype #> oValue, AValue aValue) => aValue is not null && aValue.CompareTo(oValue) > 0;
	        public static bool operator>(<#= datatype #> oValue, AValue aValue) => aValue is null || aValue.CompareTo(oValue) < 0;
            public static bool operator<=(<#= datatype #> oValue, AValue aValue) => aValue is not null && aValue.CompareTo(oValue) >= 0;
            public static bool operator>=(<#= datatype #> oValue, AValue aValue) => aValue is null || aValue.CompareTo(oValue) <= 0;

            public static bool operator<(AValue aValue, <#= datatype #> oValue) => aValue is null || aValue.CompareTo(oValue) < 0;
	        public static bool operator>(AValue aValue, <#= datatype #> oValue) => aValue is not null && aValue.CompareTo(oValue) > 0;
            public static bool operator<=(AValue aValue, <#= datatype #> oValue) => aValue is null || aValue.CompareTo(oValue) <= 0;
            public static bool operator>=(AValue aValue, <#= datatype #> oValue) => aValue is not null && aValue.CompareTo(oValue) >= 0;

            <# if(datatype != "string") { #>
            public <#= datatype #> To<#= datatype #>() => (<#= datatype #>) this;
             <# } #> 
            public bool Equals(<#= datatype #> value)
            {
                return this.DigestRequired()
                            ? this.CompareDigest(value)
                            : this.CompareTo(value) == 0;
            }

            public bool Equals(<#= datatype #> v1, <#= datatype #> v2) => v1 == v2;
            public int GetHashCode(<#= datatype #> value) => value.GetHashCode();

            public int CompareTo(<#= datatype #> value)
            {
                <# if(datatype == "string") { #>
                if(this.Value is null) return value is null ? 0 : -1;
                if(value is null) return 1;
                if(this.Value is string sValue) return sValue.CompareTo(value);
                if(this.Value is Guid gValue) return gValue.ToString().CompareTo(value);
                return Helpers.GetStableHashCode(this.Value).CompareTo(Helpers.GetStableHashCode(value));
                <# } else if(datatype == "Guid") { #>
                if(this.Value is null) return -1;
                if(this.Value is Guid gValue) return gValue.CompareTo(value);
                if(this.Value is string sValue) return sValue.CompareTo(value.ToString());
                return Helpers.GetStableHashCode(this.Value).CompareTo(Helpers.GetStableHashCode(value));
                <# } else { #>
                if(this.Value is null) return -1;
               
                try {
                    var tValue = this.Value;

                    if(tValue is <#= datatype #> cValue)
                        return cValue.CompareTo(value);

                <# if(datatype == "DateTime"
                        || datatype == "DateTimeOffset"
                        || datatype == "TimeSpan") { #>
                    if(tValue is string || tValue.GetType().IsPrimitive)
                        tValue = this.Convert< <#= datatype #> >();
                     if(tValue is IComparable vValue)
                        return vValue.CompareTo(value);                     
                <# } else { #>
                    if(tValue is string)
                         return Helpers.GetStableHashCode(tValue).CompareTo(Helpers.GetStableHashCode(value));
                    
                    tValue = ((IConvertible)tValue).ToType(typeof(decimal), null);

                    return ((decimal)tValue).CompareTo((decimal)((IConvertible)value).ToType(typeof(decimal), null));
                <# } #> 
                                                  
                } catch  {}

                return Helpers.GetStableHashCode(this.Value).CompareTo(Helpers.GetStableHashCode(value));
                <# } #>            }

        <#    }//end of foreach data type #>

        <# foreach(var datatype in jsonClassDataTypes)
        { #>

            public static implicit operator <#= datatype #> (AValue key) => key is null ? null : (<#= datatype #>) key.Convert< <#= datatype #> >();
            //public static implicit operator <#= datatype #>[] (AValue key) => (<#= datatype #>[]) key.Convert<<#= datatype #>[]>();
            
            public <#= datatype #> To<#= datatype #>() => (<#= datatype #>) this;

            public bool Equals(<#= datatype #> value)
            {
                try {
                    return this.DigestRequired()
                            ? this.CompareDigest(value)
                            : ((<#= datatype #>) this).Equals(value);
                } catch {}
                return false;
            }

            public bool Equals(<#= datatype #> v1, <#= datatype #> v2)
            {
                if(ReferenceEquals(v1,v2)) return true;
                if(v1 is null) return v2 is null;

                return v1.Equals(v2);
            }
            public int GetHashCode(<#= datatype #> value) => value?.GetHashCode() ?? 0;

        <#    }//end of foreach data type #>
        
        /// <summary>
        /// Returns the number of elements/chars if <see cref="Value"/> is either a collection or string.
        /// If <see cref="Value"/> is neither a collection or string, -1 is returned.
        /// </summary>
        /// <returns>
        /// Number of items in a collection or chars in a string, otherwise -1.
        /// </returns>
        public int Count()
        {
            return this.Value switch
            {
                string sValue => sValue.Length,
                JContainer jContainer => jContainer.Count,
                System.Collections.ICollection oValue => oValue.Count,
                System.Collections.IEnumerable iValue => iValue.Cast<object>().Count(),
                _ => -1
            };
        }

        /// <summary>
        /// Determines if <paramref name="value"/> is contained in <see cref="Value"/>.
        /// If <see cref="Value"/> is a collection, each element is compared. 
        /// If <see cref="Value"/> is a string and <paramref name="value"/> is a string, determines if param is contained in the Value, otherwise Equals is applied.
        /// If <see cref="Value"/> is an instance, the Equals method is applied.
        /// </summary>
        /// <typeparam name="T">The type of <paramref name="value"/></typeparam>
        /// <param name="value">The value used to determined if it exists</param>
        /// <returns>
        /// True if it is contained within a collection or is equal to an instance.
        /// </returns>
        /// <seealso cref="Contains{K, T}(K, T)"/>
        /// <seealso cref="ContainsKey{K}(K)"/>
        public bool Contains<T>(T value)
        {
            return this.Value switch
            {
                string sValue => value is not null
                                    && (value is string svalue
                                            && sValue.Contains(svalue))
                                        || this.Equals(value),
                JArray jArray => jArray.Contains(JToken.FromObject(value)),
                IEnumerable<T> iValue => iValue.Contains(value),
                IEnumerable<KeyValuePair<string, object>> iKeyValuePair
                    => iKeyValuePair.Any(kvp => Helpers.Equals(kvp.Value, value)),
                System.Collections.IDictionary cDict
                    => cDict.Values.Cast<object>().Any(i => Helpers.Equals(i, value)),
                System.Collections.IEnumerable iValue => iValue.Cast<object>().Any(i => Helpers.Equals(i, value)),                
                _ => this.Equals(value)
            };
        }

        /// <summary>
        /// Determines if <paramref name="key"/> and <paramref name="value"/> is contained in <see cref="Value"/>.
        /// If <see cref="Value"/> is a IDictionary, <seealso cref="JsonDocument"/>, or <see cref="IDictionary{TKey, TValue}"/>, each Key/Value pair is compared. 
        /// If <see cref="Value"/> is an instance, false is always returned.
        /// </summary>
        /// <typeparam name="K">The type of <paramref name="key"/></typeparam>
        /// <typeparam name="T">The type of <paramref name="value"/></typeparam>
        /// <param name="key">The key used to obtain the value</param>
        /// <param name="value">The value used to determined if it exists</param>
        /// <returns>
        /// True if it is contained within a collection or false otherwise.
        /// </returns>
        /// <seealso cref="Contains{T}(T)"/>
        /// <seealso cref="ContainsKey{K}(K)"/>
        public bool Contains<K, T>(K key, T value)
        {
            return this.Value switch
            {
                JObject jObj
                    => key is string sKey
                            && jObj.ContainsKey(sKey)
                            && Helpers.Equals(jObj[sKey], value),
                IDictionary<K, T> tDict
                    => tDict.ContainsKey(key)
                            && Helpers.Equals(tDict[key], value),
                System.Collections.IDictionary cDict
                    => cDict.Contains((object)key)
                            && Helpers.Equals(cDict[key], value),
                _ => false
            };
        }

        /// <summary>
        /// Determines if <paramref name="key"/> is a key/property field within a Dictionary or JObject.
        /// </summary>
        /// <typeparam name="K">The type of <paramref name="key"/></typeparam>
        /// <param name="key">The value used to determined if the key exists</param>
        /// <returns>
        /// True is the key/property field exists.
        /// </returns>
        /// <seealso cref="Contains{K, T}(K, T)"/>
        /// <seealso cref="Contains{T}(T)"/>
        public bool ContainsKey<K>(K key)
        {
            return this.Value switch
            {
                JObject jObj
                    => key is string sKey
                            && jObj.ContainsKey(sKey),                
                System.Collections.IDictionary cDict
                    => cDict.Contains((object) key),
                _ => false
            };
        }
    }
}
